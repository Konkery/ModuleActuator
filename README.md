<div style = "font-family: 'Open Sans', sans-serif; font-size: 16px">

# ModuleActuator
<div style = "color: #555">
    <p align="center">
    <img src="./res/logo.png" width="400" title="hover text">
    </p>
</div>

## Лицензия
////

### Описание
<div style = "color: #555">

Модуль Actuator предназначен для обеспечения разработчиков функционалом для удобной и эффективной работы с актуаторами в рамках фреймворка EcoLight. 
Наделяет актуаторы полями и методами, которые покрывают типовые задачи идентификации и управления. Для этого модуль создает унифицированный интерфейс, разделяя объект актуатора на каналы. 
Каждый канал отвечает за отдельный аспект работы актуатора.
Данный подход обеспечивает единообразное взаимодействие с различными типами актуаторов, упрощая процесс учета и делегирования команд.

Одной из важнейших особенностей модуля является заложенный подход к созданию, организации и управлению наборами инструкций, которые выполняются актуатором в асинхронном режиме. В парадигме фреймворка EcoLight такие наборы инструкций именуются тасками (от англ. tasks). Модуль каждого актуатора имеет набор базовых тасков, а функционал рассматриваемой архитектуры позволяет расширять их коллекцию даже во время выполнения программы.   

Реализованный подход отличается классической работы с актуаторами набором механизмов, которые позволяют

1. Предотвращать вызов тасков, которые не могут начать выполняться в данный момент;
2. Отменять выполнение последнего вызванного таска;
3. Составлять цепочки с упорядоченным вызовом тасков.

Также заложенный в модуль функционал включает в себя поэтапную автоматическую обработку вх. сигнала на канал актуатора, что повышает надежность и удобство работы. Этот процесс включает в себя следующие этапы:
- Супрессия: входные данные подвергаются ограничению с использованием супрессорной функции. Это обеспечивает то, что значения с актуатора находятся в заданных пределах, что позволяет учесть границы работы актуатора или предотвратить определенные ошибки; 
- Трансформация линейной функцией: в случаях, когда величину, подаваемую на актуатор необходимо преобразовать (например, задать соответствие между физ.величиной и значением, которое должно быть подано на устройство), применяется линейная функция. Эта функция трансформирует значения согласно коэффициентам, которые задает пользователь;
- Проверка зоны измерений: значения с актуатора сверяются с зонами измерений, настраиваемые пользователем. Если значение выходит за пределы заданных зон, это активировать соответствующие реакции в виде коллбэков.

Больше об обработке данных в соответствующем [разделе](./README_DATA_REFINE.md#методы). 

Набор классов, обеспечивающих функционал актуатора делитcя на такие части: 
- Основная, которая состоит из:
    - ветки классов [ClassAncestorActuator](./README_ANCESTOR.md) и [ClassMiddleActuator](./README_MIDDLE.md), хранящих в себе поля и методы, общих для всех актуаторов;
    - класса [ClassChannelActuator](README_CHANNEL.md), который представляет собой интерфейс для работы с отдельным каналом актуатора;
    - класса [ClassTask](README_TASK.md), который представляет сущность таска и осуществляет управление им;
- Сервисная: 
    - [ClassDataRefine](./README_DATA_REFINE.md) реализует математико-логический аппарат для обработки и корректировки передаваемых значений;
    - [ClassAlarms](./README_ALARMS.md) добавляет поддержку зон измерения и алармов;  
- Прикладная - класс, отвечающий за отдельно взятый канал актуатора. Этот класс реализуется вне данного стека наследованием от **ClassMiddleActuator** и реализацией его интерфейсов.

<div align='left'>
    <img src="./res/main-diagram.png" alt="Image not found">
</div>

</div>

### Примеры
#### Инициализация и запуск пьезо-зуммера
<div style = "color: #555">

```js
//Импорт зависимостей
const ClassAppError     = require('ModuleAppError.min');
    require('ModuleAppMath.min').is();
const ClassMiddleActuator = require('ModuleActuator.min');
const ClassBuzzer         = require('ModuleBuzzer.min');

//Аргументы для инициализации объекта актуатора
const actuator_props = ({
    name: "Buzzer",
    type: "actuator",
    channelNames: ['freq'],
    typeInSignals: ["analog"],
    quantityChannel: 1,
    busTypes: [],
    manufacturingData: {
        IDManufacturing: [
            { "Adafruit": "PS1240" }  
        ],
        IDsupplier: [
            { "Adafruit": "PS1240" }  
        ],
        HelpSens: "Piezo buzzer"
    }
});
//Инициализация 
const bz = new ClassBuzzer(actuator_props, { pins: [P2] });
const ch = bz.GetChannel(0);
//Запуск работы зуммера с частотой 600 Гц
ch.On(600);
//Запуск с другой частотой через 1 сек
setTimeout(() => { 
    ch.On(1000);    
}, 1500);
//Прекращение работы
setTimeout(() => { 
    ch.Off(); 
}, 3000);
```

</div>

#### Запуск цепочки тасков
<div style = "color: #555">

```js
//Вызов одного пика через основной, универсальный таск 
ch.RunTask('PlaySound', { freq: 300, numRep: 1, prop: 0.5, pulseDur: 800 });  
.then(
    // Вызов пика через таск, принимающий частоту и длину импульса 
    () => ch.RunTask('BeepOnce', 500, 800);
).then(
    // вызов двойного звукового сигнала
    () => ch.RunTask('BeepTwice', 800, 500);                   
).then(
    () => { console.log('Done!'); }
);
```

</div>

#### Добавление нового таска
<div style = "color: #555">

```js
//Объявление элементарного таска, запускающего зуммер на 3 сек
ch.AddTask('Beep3sec', (freq) => {
    this.On(freq);
    setTimeout(() => {
        this.Off();
        //Завершение выполнения таска
        this.ResolveTask(0);
    }, 3000);
});

ch.RunTask('Beep3sec', 500);
    .then(() => print(`Done after 3 sec!`));
```

</div>

#### Отмена выполнения таска после его вызова 
<div style = "color: #555">

```js
ch.RunTask('BeepTwice', 500, 1200);

setTimeout(() => {
    ch.CancelTask();
}, 1000);
```

</div>

#### Результат выполнения:

<div align='left'>
    <img src="" alt="Image not found">
</div>

### Зависимости
<div style = "color: #555">

- <mark style="background-color: lightblue">[ClassAppError](https://github.com/Konkery/ModuleAppError/blob/main/README.md)</mark>
</div>

</div>
    